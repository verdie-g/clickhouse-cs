using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ClickHouse.Driver.Diagnostic;
using ClickHouse.Driver.Http;
using ClickHouse.Driver.Logging;
using ClickHouse.Driver.Utility;
using Microsoft.Extensions.Logging;

namespace ClickHouse.Driver.ADO;

public class ClickHouseConnection : DbConnection, IClickHouseConnection, ICloneable, IDisposable
{
    private const string CustomSettingPrefix = "set_";

    private readonly List<IDisposable> disposables = new();
    private readonly ConcurrentDictionary<string, Lazy<ILogger>> loggerCache = new();
    private volatile ConnectionState state = ConnectionState.Closed; // Not an autoproperty because of interface implementation

    // HTTP client management
    private HttpClient providedHttpClient;
    private IHttpClientFactory providedHttpClientFactory;
    private string httpClientName;
    private IHttpClientFactory httpClientFactory;

    /// <summary>
    /// This lock is used to serialize requests when using sessions,
    /// because ClickHouse does not support using the same session from multiple connections.
    /// </summary>
    private SemaphoreSlim sessionRequestLock;

    // Server state (populated after connection)
    private Version serverVersion;
    private string serverTimezone;
    private Feature supportedFeatures;

    // Configuration fields
    private Uri serverUri;

    public ClickHouseConnection()
        : this(string.Empty)
    {
    }

    public ClickHouseConnection(string connectionString)
        : this(ClickHouseClientSettings.FromConnectionString(connectionString))
    {
    }

    public ClickHouseConnection(string connectionString, bool skipServerCertificateValidation)
    {
        var settings = new ClickHouseClientSettings(connectionString)
        {
            SkipServerCertificateValidation = skipServerCertificateValidation,
        };

        Settings = settings;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using provided HttpClient.
    /// Note that HttpClient must have AutomaticDecompression enabled if compression is not disabled in connection string
    /// </summary>
    /// <param name="connectionString">Connection string</param>
    /// <param name="httpClient">instance of HttpClient</param>
    public ClickHouseConnection(string connectionString, HttpClient httpClient)
    {
        var settings = new ClickHouseClientSettings(connectionString)
        {
            HttpClient = httpClient,
        };

        Settings = settings;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using an HttpClient generated by the provided <paramref name="httpClientFactory"/>.
    /// </summary>
    /// <param name="connectionString">The ClickHouse connection string.</param>
    /// <param name="httpClientFactory">The factory to be used for creating the clients.</param>
    /// <param name="httpClientName">
    /// The name of the HTTP client you want to be created using the provided factory.
    /// If left empty, the default client will be created.
    /// </param>
    /// <remarks>
    /// <list type="bullet">
    /// <item>
    /// If compression is not disabled in the <paramref name="connectionString"/>, the <paramref name="httpClientFactory"/>
    /// must be configured to enable <see cref="HttpClientHandler.AutomaticDecompression"/> for its generated clients.
    /// <example>
    /// For example you can do this while registering the HTTP client:
    /// <code>
    /// services.AddHttpClient("ClickHouseClient").ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    /// {
    ///     AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
    /// });
    /// </code>
    /// </example>
    /// </item>
    /// <item>
    /// The <paramref name="httpClientFactory"/> must set the timeout for its clients if needed.
    /// <example>
    /// For example you can do this while registering the HTTP client:
    /// <code>
    /// services.AddHttpClient("ClickHouseClient", c => c.Timeout = TimeSpan.FromMinutes(5));
    /// </code>
    /// </example>
    /// </item>
    /// </list>
    /// </remarks>
    public ClickHouseConnection(string connectionString, IHttpClientFactory httpClientFactory, string httpClientName = "")
    {
        var settings = new ClickHouseClientSettings(connectionString)
        {
            HttpClientFactory = httpClientFactory,
            HttpClientName = httpClientName,
        };

        Settings = settings;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using ClickHouseClientSettings.
    /// </summary>
    /// <param name="settings">The settings to use for this connection</param>
    public ClickHouseConnection(ClickHouseClientSettings settings)
    {
        if (settings == null)
            throw new ArgumentNullException(nameof(settings));
        Settings = settings;
    }

    private ILoggerFactory loggerFactory;

    /// <summary>
    /// Gets a logger for the specified category name.
    /// Loggers are lazily instantiated and cached for performance.
    /// </summary>
    /// <param name="categoryName">The category name for the logger.</param>
    /// <returns>An ILogger instance, or null if no LoggerFactory is configured.</returns>
    internal ILogger GetLogger(string categoryName)
    {
        if (loggerFactory == null)
            return null;

        // Cache is used here in case the logger factory implementation provided does not do caching on its own
        return loggerCache.GetOrAdd(
            categoryName,
            key => new Lazy<ILogger>(() => loggerFactory.CreateLogger(key))).Value;
    }

    /// <summary>
    /// Gets the string defining connection settings for ClickHouse server
    /// Example: Host=localhost;Port=8123;Username=default;Password=123;Compression=true
    /// It is generally recommended create a new connection instead of modifying the settings of an existing one.
    /// </summary>
    public sealed override string ConnectionString
    {
        get => ConnectionStringBuilder.ToString();
        set => Settings = new ClickHouseClientSettings(value);
    }

    public ClickHouseClientSettings Settings { get;
        set
        {
            if (State == ConnectionState.Open)
                throw new InvalidOperationException("Cannot change settings while connection is open.");
            
            field = value;
            ApplySettings();
        }
    }

    public IDictionary<string, object> CustomSettings => Settings?.CustomSettings;

    public override ConnectionState State => state;

    public override string Database => Settings.Database;

    internal string Username => Settings.Username;

    internal Uri ServerUri => serverUri;

    internal string RedactedConnectionString
    {
        get
        {
            var builder = ConnectionStringBuilder;
            builder.Password = "****";
            return builder.ToString();
        }
    }

    public string ServerTimezone => serverTimezone;

    public override string DataSource { get; }

    public override string ServerVersion => serverVersion?.ToString();

    public bool UseCompression => Settings.UseCompression;

    public bool SkipServerCertificateValidation => Settings.SkipServerCertificateValidation;

    public bool UseFormDataParameters => Settings.UseFormDataParameters;

    /// <summary>
    /// Gets enum describing which ClickHouse features are available on this particular server version
    /// Requires connection to be in Open state
    /// </summary>
    public virtual Feature SupportedFeatures
    {
        get => state == ConnectionState.Open ? supportedFeatures : throw new InvalidOperationException();
        private set => supportedFeatures = value;
    }

    private void ApplySettings()
    {
        Settings.Validate();

        serverUri = new UriBuilder(Settings.Protocol, Settings.Host, Settings.Port, Settings.Path ?? string.Empty).Uri;

        // HttpClientFactory/HttpClient
        providedHttpClient = Settings.HttpClient;
        providedHttpClientFactory = Settings.HttpClientFactory;
        httpClientName = Settings.HttpClientName;

        // Logging
        loggerCache.Clear();
        loggerFactory = Settings.LoggerFactory;

#if NET5_0_OR_GREATER
        // Debug mode
        if (Settings.EnableDebugMode)
        {
            TraceHelper.Activate(Settings.LoggerFactory);
        }
#endif

        ResetHttpClientFactory();
    }

    private void ResetHttpClientFactory()
    {
        // If current httpClientFactory is owned by this connection, dispose of it
        if (httpClientFactory is IDisposable d && disposables.Contains(d))
        {
            GetLogger(ClickHouseLogCategories.Connection)?.LogDebug("Disposing HTTP client factory owned by connection.");
            d.Dispose();
            disposables.Remove(d);
        }

        // Dispose and reset the session lock if it exists
        sessionRequestLock?.Dispose();
        sessionRequestLock = null;

        // If we have a HttpClient provided, use it
        if (providedHttpClient != null)
        {
            GetLogger(ClickHouseLogCategories.Connection)?.LogInformation("Using provided HttpClient instance.");
            httpClientFactory = new CannedHttpClientFactory(providedHttpClient);
        }

        // If we have a provided client factory, use that
        else if (providedHttpClientFactory != null)
        {
            GetLogger(ClickHouseLogCategories.Connection)?.LogInformation("Using provided IHttpClientFactory instance.");
            httpClientFactory = providedHttpClientFactory;
        }

        // If sessions are enabled without a provided client/factory, use single connection factory
        else if (Settings.UseSession && !string.IsNullOrEmpty(Settings.SessionId))
        {
            GetLogger(ClickHouseLogCategories.Connection)?.LogInformation("Creating single-connection HttpClientFactory for session {SessionId}.", Settings.SessionId);
            var factory = new SingleConnectionHttpClientFactory(SkipServerCertificateValidation) { Timeout = Settings.Timeout };
            disposables.Add(factory);
            httpClientFactory = factory;
        }

        // Default case - use default connection pool
        else
        {
            GetLogger(ClickHouseLogCategories.Connection)?.LogInformation("Using default pooled HttpClientFactory.");
            httpClientFactory = new DefaultPoolHttpClientFactory(SkipServerCertificateValidation) { Timeout = Settings.Timeout };
        }

        // Initialize session lock if sessions are enabled (regardless of how HttpClient is configured)
        if (Settings.UseSession && !string.IsNullOrEmpty(Settings.SessionId))
        {
            sessionRequestLock = new SemaphoreSlim(1, 1);
            GetLogger(ClickHouseLogCategories.Connection)?.LogDebug("Session request serialization enabled for session {SessionId}.", Settings.SessionId);
        }
    }

    public override DataTable GetSchema() => GetSchema(null, null);

    public override DataTable GetSchema(string collectionName) => GetSchema(collectionName, null);

    public override DataTable GetSchema(string collectionName, string[] restrictionValues) => SchemaDescriber.DescribeSchema(this, collectionName, restrictionValues);

    internal static async Task<HttpResponseMessage> HandleError(HttpResponseMessage response, string query, Activity activity)
    {
        if (response.IsSuccessStatusCode)
        {
            activity.SetSuccess();
            return response;
        }

        var error = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
        var ex = ClickHouseServerException.FromServerResponse(error, query);
        activity.SetException(ex);
        throw ex;
    }

    public override void ChangeDatabase(string databaseName)
    {
        Settings.Database = databaseName;
    }

    public object Clone() => new ClickHouseConnection(ConnectionString);

    public override void Close() => state = ConnectionState.Closed;

    public override void Open() => OpenAsync().ConfigureAwait(false).GetAwaiter().GetResult();

    public override async Task OpenAsync(CancellationToken cancellationToken)
    {
        const string versionQuery = "SELECT version(), timezone() FORMAT TSV";

        GetLogger(ClickHouseLogCategories.Connection)?.LogDebug("Opening ClickHouse connection to {Endpoint}.", serverUri);
        LoggingHelpers.LogHttpClientConfiguration(GetLogger(ClickHouseLogCategories.Connection), httpClientFactory);

        if (State == ConnectionState.Open)
            return;
        using var activity = this.StartActivity("OpenAsync");
        activity.SetQuery(versionQuery);

        try
        {
            var uriBuilder = CreateUriBuilder();
            var request = new HttpRequestMessage(HttpMethod.Post, uriBuilder.ToString())
            {
                Content = new StringContent(versionQuery, Encoding.UTF8),
            };
            AddDefaultHttpHeaders(request.Headers);
            using var response = await HandleError(await SendAsync(request, HttpCompletionOption.ResponseContentRead, cancellationToken).ConfigureAwait(false), versionQuery, activity).ConfigureAwait(false);
#if NET5_0_OR_GREATER
            var data = await response.Content.ReadAsByteArrayAsync(cancellationToken).ConfigureAwait(false);
#else
            var data = await response.Content.ReadAsByteArrayAsync().ConfigureAwait(false);
#endif

            if (data.Length > 2 && data[0] == 0x1F && data[1] == 0x8B) // Check if response starts with GZip marker
                throw new InvalidOperationException("ClickHouse server returned compressed result but HttpClient did not decompress it. Check HttpClient settings");

            if (data.Length == 0)
                throw new InvalidOperationException("ClickHouse server did not return version, check if the server is functional");

            var serverVersionAndTimezone = Encoding.UTF8.GetString(data).Trim().Split('\t');

            serverVersion = ParseVersion(serverVersionAndTimezone[0]);
            serverTimezone = serverVersionAndTimezone[1];
            SupportedFeatures = ClickHouseFeatureMap.GetFeatureFlags(serverVersion);
            state = ConnectionState.Open;

            GetLogger(ClickHouseLogCategories.Connection)?.LogDebug("Connection to {Endpoint} opened (ServerVersion: {ServerVersion}).", serverUri, serverVersion);
        }
        catch (Exception ex)
        {
            state = ConnectionState.Broken;
            GetLogger(ClickHouseLogCategories.Connection)?.LogError(ex, "Failed to open ClickHouse connection to {Endpoint}.", serverUri);
            throw;
        }
    }

    /// <summary>
    /// Warning: implementation-specific API. Exposed to allow custom optimizations
    /// May change in future versions
    /// </summary>
    /// <param name="sql">SQL query to add to URL, may be empty</param>
    /// <param name="data">Raw stream to be sent. May contain SQL query at the beginning. May be gzip-compressed</param>
    /// <param name="isCompressed">indicates whether "Content-Encoding: gzip" header should be added</param>
    /// <param name="token">Cancellation token</param>
    /// <param name="queryId">Query id</param>
    /// <returns>Task-wrapped HttpResponseMessage object</returns>
    public async Task<HttpResponseMessage> PostStreamAsync(string sql, Stream data, bool isCompressed, CancellationToken token, string queryId = null)
    {
        var content = new StreamContent(data);
        return await PostStreamAsync(sql, content, isCompressed, queryId, token).ConfigureAwait(false);
    }

    /// <summary>
    /// Warning: implementation-specific API. Exposed to allow custom optimizations
    /// May change in future versions
    /// </summary>
    /// <param name="sql">SQL query to add to URL, may be empty</param>
    /// <param name="callback">Callback invoked to write to the stream. May contain SQL query at the beginning. May be gzip-compressed</param>
    /// <param name="isCompressed">indicates whether "Content-Encoding: gzip" header should be added</param>
    /// <param name="token">Cancellation token</param>
    /// <param name="queryId">Query id</param>
    /// <returns>Task-wrapped HttpResponseMessage object</returns>
    public async Task<HttpResponseMessage> PostStreamAsync(string sql, Func<Stream, CancellationToken, Task> callback, bool isCompressed, CancellationToken token, string queryId = null)
    {
        var content = new StreamCallbackContent(callback, token);
        return await PostStreamAsync(sql, content, isCompressed, queryId, token).ConfigureAwait(false);
    }

    private async Task<HttpResponseMessage> PostStreamAsync(string sql, HttpContent content, bool isCompressed, string queryId, CancellationToken token)
    {
        using var activity = this.StartActivity("PostStreamAsync");
        activity.SetQuery(sql);

        var builder = CreateUriBuilder(sql);
        builder.QueryId = queryId;

        using var postMessage = new HttpRequestMessage(HttpMethod.Post, builder.ToString());
        AddDefaultHttpHeaders(postMessage.Headers);

        postMessage.Content = content;
        postMessage.Content.Headers.ContentType = new MediaTypeHeaderValue("application/octet-stream");
        if (isCompressed)
        {
            postMessage.Content.Headers.Add("Content-Encoding", "gzip");
        }

        GetLogger(ClickHouseLogCategories.Transport)?.LogDebug("Sending streamed request to {Endpoint} (Compressed: {Compressed}).", serverUri, isCompressed);

        try
        {
            using var response = await SendAsync(postMessage, HttpCompletionOption.ResponseContentRead, token).ConfigureAwait(false);
            GetLogger(ClickHouseLogCategories.Transport)?.LogDebug("Streamed request to {Endpoint} received response {StatusCode}.", serverUri, response.StatusCode);

            return await HandleError(response, sql, activity).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            GetLogger(ClickHouseLogCategories.Transport)?.LogError(ex, "Streamed request to {Endpoint} failed.", serverUri);
            throw;
        }
    }

    public new ClickHouseCommand CreateCommand(string commandText = null) => new (this) { CommandText = commandText };

    void IDisposable.Dispose()
    {
        GC.SuppressFinalize(this);
        foreach (var d in disposables)
            d.Dispose();
        sessionRequestLock?.Dispose();
    }

    internal static Version ParseVersion(string versionString)
    {
        if (string.IsNullOrWhiteSpace(versionString))
            throw new ArgumentException($"'{nameof(versionString)}' cannot be null or whitespace.", nameof(versionString));
        var parts = versionString.Split(DotSeparator, StringSplitOptions.RemoveEmptyEntries)
            .Select(s => int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out var i) ? i : 0)
            .ToArray();
        if (parts.Length == 0 || parts[0] == 0)
            throw new InvalidOperationException($"Invalid version: {versionString}");
        return new Version(parts.ElementAtOrDefault(0), parts.ElementAtOrDefault(1), parts.ElementAtOrDefault(2), parts.ElementAtOrDefault(3));
    }

    internal static string ExtractQueryId(HttpResponseMessage response)
    {
        const string queryIdHeader = "X-ClickHouse-Query-Id";
        if (response.Headers.Contains(queryIdHeader))
            return response.Headers.GetValues(queryIdHeader).FirstOrDefault();
        else
            return null;
    }

    internal HttpClient HttpClient => httpClientFactory.CreateClient(httpClientName);

    /// <summary>
    /// Sends an HTTP request, serializing requests when sessions are enabled to prevent concurrent session access.
    /// </summary>
    internal async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken)
    {
        // This will only have a value when sessions are enabled
        var lockRef = sessionRequestLock;
        if (lockRef != null)
        {
            await lockRef.WaitAsync(cancellationToken).ConfigureAwait(false);
            try
            {
                // Force ResponseContentRead to ensure response is fully buffered before releasing lock
                return await HttpClient.SendAsync(request, HttpCompletionOption.ResponseContentRead, cancellationToken).ConfigureAwait(false);
            }
            finally
            {
                lockRef.Release();
            }
        }

        return await HttpClient.SendAsync(request, completionOption, cancellationToken).ConfigureAwait(false);
    }

    internal TypeSettings TypeSettings => new TypeSettings(Settings.UseCustomDecimals, Settings.UseServerTimezone ? serverTimezone : TypeSettings.DefaultTimezone);

    internal ClickHouseUriBuilder CreateUriBuilder(string sql = null) => new ClickHouseUriBuilder(serverUri)
    {
        Database = Database,
        SessionId = Settings.UseSession ? Settings.SessionId : null,
        UseCompression = UseCompression,
        ConnectionQueryStringParameters = CustomSettings
            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value),
        ConnectionRoles = Settings.Roles,
        Sql = sql,
    };

    internal Task EnsureOpenAsync() => state != ConnectionState.Open ? OpenAsync() : Task.CompletedTask;

    internal void AddDefaultHttpHeaders(HttpRequestHeaders headers, string bearerTokenOverride = null)
    {
        var userAgentInfo = UserAgentProvider.Info;

        // Priority: command-level bearer token > connection-level bearer token > basic auth
        var bearerToken = bearerTokenOverride ?? Settings.BearerToken;
        if (!string.IsNullOrEmpty(bearerToken))
        {
            headers.Authorization = new AuthenticationHeaderValue("Bearer", bearerToken);
        }
        else
        {
            headers.Authorization = new AuthenticationHeaderValue("Basic", Convert.ToBase64String(Encoding.UTF8.GetBytes($"{Settings.Username}:{Settings.Password}")));
        }

        headers.UserAgent.Add(userAgentInfo.DriverProductInfo);
        headers.UserAgent.Add(userAgentInfo.SystemProductInfo);
        headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        headers.Accept.Add(new MediaTypeWithQualityHeaderValue("text/csv"));
        headers.Accept.Add(new MediaTypeWithQualityHeaderValue("application/octet-stream"));
        if (UseCompression)
        {
            headers.AcceptEncoding.Add(new StringWithQualityHeaderValue("gzip"));
            headers.AcceptEncoding.Add(new StringWithQualityHeaderValue("deflate"));
        }

        // Apply custom headers (blocked headers are silently ignored for security)
        foreach (var kvp in Settings.CustomHeaders)
        {
            if (!IsBlockedHeader(kvp.Key))
            {
                headers.TryAddWithoutValidation(kvp.Key, kvp.Value);
            }
        }
    }

    private static bool IsBlockedHeader(string headerName)
    {
        return string.Equals(headerName, "Connection", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(headerName, "Authorization", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(headerName, "User-Agent", StringComparison.OrdinalIgnoreCase);
    }

    internal ClickHouseConnectionStringBuilder ConnectionStringBuilder => ClickHouseConnectionStringBuilder.FromSettings(Settings);

    private static readonly char[] DotSeparator = ['.'];

    protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel) => throw new NotSupportedException();

    protected override DbCommand CreateDbCommand() => CreateCommand();
}
